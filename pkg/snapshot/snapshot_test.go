package snapshot

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"net"
	"net/http"
	"net/http/httptest"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/Layr-Labs/sidecar/internal/config"
	"github.com/Layr-Labs/sidecar/internal/logger"
	"github.com/Layr-Labs/sidecar/internal/tests"
	"github.com/Layr-Labs/sidecar/pkg/postgres"
	"github.com/Layr-Labs/sidecar/pkg/postgres/migrations"
	"github.com/stretchr/testify/assert"
	"go.uber.org/zap"
)

func TestNewSnapshotService(t *testing.T) {
	cfg := &SnapshotConfig{}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	assert.NotNil(t, svc, "SnapshotService should not be nil")
	assert.Equal(t, cfg, svc.cfg, "SnapshotConfig should match")
	assert.Equal(t, l, svc.l, "Logger should match")
}

func TestValidateCreateSnapshotConfig(t *testing.T) {
	cfg := &SnapshotConfig{
		Host:       "localhost",
		Port:       5432,
		DbName:     "testdb",
		User:       "testuser",
		Password:   "testpassword",
		SchemaName: "public",
		OutputFile: "/tmp/test_snapshot.sql",
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	err = svc.validateCreateSnapshotConfig()
	assert.NoError(t, err, "Snapshot config should be valid")
}

func TestValidateCreateSnapshotConfigMissingOutputFile(t *testing.T) {
	cfg := &SnapshotConfig{
		Host:       "localhost",
		Port:       5432,
		DbName:     "testdb",
		User:       "testuser",
		Password:   "testpassword",
		SchemaName: "public",
		OutputFile: "",
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	err = svc.validateCreateSnapshotConfig()
	assert.Error(t, err, "Snapshot config should be invalid if output file is missing")
}

func TestSetupSnapshotDump(t *testing.T) {
	cfg := &SnapshotConfig{
		Host:       "localhost",
		Port:       5432,
		DbName:     "testdb",
		User:       "testuser",
		Password:   "testpassword",
		SchemaName: "public",
		OutputFile: "/tmp/test_snapshot.sql",
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	dump, err := svc.setupSnapshotDump()
	assert.NoError(t, err, "Dump setup should not fail")
	assert.NotNil(t, dump, "Dump should not be nil")
}

func TestSetupRestore(t *testing.T) {
	cfg := &SnapshotConfig{
		Host:        "localhost",
		Port:        5432,
		DbName:      "testdb",
		User:        "testuser",
		Password:    "testpassword",
		SchemaName:  "public",
		Input:       "/tmp/test_snapshot.sql",
		VerifyInput: true,
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	restore, err := svc.setupRestore()
	assert.NoError(t, err, "Restore setup should not fail")
	assert.NotNil(t, restore, "Restore should not be nil")
}

func TestSaveOutputFileHash(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "TestSaveOutputFileHash.sql")
	outputHashFile := outputFile + ".sha256sum"
	_, err := os.Create(outputFile)
	assert.NoError(t, err, "Creating output file should not fail")

	// Use the pure function directly
	err = saveOutputFileHash(outputFile, outputHashFile)
	assert.NoError(t, err, "Saving output file hash should not fail")

	hash, err := os.ReadFile(outputHashFile)
	assert.NoError(t, err, "Reading output hash file should not fail")
	assert.NotEmpty(t, hash, "Output hash file should not be empty")

	// Validate the hash file content
	hashParts := strings.Fields(string(hash))
	assert.Equal(t, 2, len(hashParts), "Output hash file should contain two parts: hash and filename")
	assert.Equal(t, filepath.Base(outputFile), hashParts[1], "Output hash file should contain the correct filename")
	assert.Equal(t, sha256.Size*2, len(hashParts[0]), "Output hash file should have the correct hash length")

	// Compare the hash with the one generated by sha256sum
	cmd := exec.Command("sha256sum", outputFile)
	sha256sumOutput, err := cmd.Output()
	assert.NoError(t, err, "Executing sha256sum should not fail")

	sha256sumParts := strings.Fields(string(sha256sumOutput))
	assert.Equal(t, 2, len(sha256sumParts), "sha256sum output should contain two parts: hash and filename")
	assert.Equal(t, sha256sumParts[0], hashParts[0], "Hashes should match between sha256sum and saveOutputFileHash")
}

func TestSaveOutputFileHashCompatibilityWithSha256sum(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "TestSaveOutputFileHashCompatibility.sql")
	outputHashFile := getHashName(outputFile)

	// Create a dummy output file
	content := []byte("test content for sha256sum compatibility")
	err := os.WriteFile(outputFile, content, 0644)
	assert.NoError(t, err, "Creating output file should not fail")

	// Generate the hash file
	err = saveOutputFileHash(outputFile, outputHashFile)
	assert.NoError(t, err, "Saving output file hash should not fail")

	// Shell out to sha256sum to verify the hash
	cmd := exec.Command("sha256sum", outputFile)
	sha256sumOutput, err := cmd.Output()
	assert.NoError(t, err, "Executing sha256sum should not fail")

	// Extract the hash from the sha256sum output
	sha256sumParts := strings.Fields(string(sha256sumOutput))
	assert.Equal(t, 2, len(sha256sumParts), "sha256sum output should contain two parts: hash and filename")

	// Read the generated hash file
	hashContent, err := os.ReadFile(outputHashFile)
	assert.NoError(t, err, "Reading output hash file should not fail")

	// Validate the format of the hash file
	hashParts := strings.Fields(string(hashContent))
	assert.Equal(t, 2, len(hashParts), "Output hash file should contain two parts: hash and filename")
	assert.Equal(t, filepath.Base(outputFile), hashParts[1], "Output hash file should contain the correct filename")
	assert.Equal(t, sha256.Size*2, len(hashParts[0]), "Output hash file should have the correct hash length")

	// Compare the hash from sha256sum with the one generated by saveOutputFileHash
	assert.Equal(t, sha256sumParts[0], hashParts[0], "Hashes should match between sha256sum and saveOutputFileHash")
}

func TestCleanupTempFiles(t *testing.T) {
	tempDir := t.TempDir()
	tempFile := filepath.Join(tempDir, "TestCleanupTempFiles.tmp")
	_, err := os.Create(tempFile)
	assert.NoError(t, err, "Creating temp file should not fail")

	// Use the standalone cleanupTempFiles function
	logger, _ := zap.NewDevelopment()
	cleanupTempFiles([]string{tempFile}, logger)

	_, err = os.Stat(tempFile)
	if !os.IsNotExist(err) {
		// Attempt to remove the file if it wasn't removed by the cleanupTempFiles
		removeErr := os.Remove(tempFile)
		assert.NoError(t, removeErr, "Removing temp file manually should not fail")
	}
	assert.True(t, os.IsNotExist(err), "Temp file should be removed")
}

func TestValidateInputFileHash(t *testing.T) {
	tempDir := t.TempDir()
	inputFile := filepath.Join(tempDir, "TestValidateInputFileHash.sql")
	hashFile := filepath.Join(tempDir, "TestValidateInputFileHash.sql.sha256sum")
	content := []byte("test content")
	err := os.WriteFile(inputFile, content, 0644)
	assert.NoError(t, err, "Writing to input file should not fail")

	// Shell out to sha256sum to create the hash file
	cmd := exec.Command("sha256sum", inputFile)
	sha256sumOutput, err := cmd.Output()
	assert.NoError(t, err, "Executing sha256sum should not fail")

	// Write the sha256sum output to the hash file
	err = os.WriteFile(hashFile, sha256sumOutput, 0644)
	assert.NoError(t, err, "Writing sha256sum output to hash file should not fail")

	err = validateInputFileHash(inputFile, hashFile)
	assert.NoError(t, err, "Input file hash should be valid")
}

func TestGetFileHash(t *testing.T) {
	tempDir := t.TempDir()
	inputFile := filepath.Join(tempDir, "TestGetFileHash.sql")
	content := []byte("test content")
	err := os.WriteFile(inputFile, content, 0644)
	assert.NoError(t, err, "Writing to input file should not fail")

	hash, err := getFileHash(inputFile)
	assert.NoError(t, err, "Getting file hash should not fail")

	expectedHash := sha256.Sum256(content)
	assert.Equal(t, expectedHash[:], hash, "File hash should match expected hash")
}

func TestDownloadFile(t *testing.T) {
	// Create a test server that serves a simple text file
	testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, "This is a test file.")
	}))
	defer testServer.Close()

	// Generate unique file names using the current timestamp
	uniqueID := fmt.Sprintf("%d", time.Now().UnixNano())
	inputFileName := uniqueID + "_downloaded_snapshot.dump"

	tempDir := t.TempDir()
	inputFilePath := filepath.Join(tempDir, inputFileName)

	// Use the test server's URL to test the downloadFile function
	err := downloadFile(testServer.URL, inputFilePath)
	assert.NoError(t, err, "downloadFile should not return an error")

	// Schedule the file for removal after the test completes
	defer func() {
		if err := os.Remove(inputFilePath); err != nil {
			t.Logf("Failed to remove downloaded file: %v", err)
		}
	}()

	// Verify the file was downloaded correctly
	content, err := os.ReadFile(inputFilePath)
	assert.NoError(t, err, "Reading downloaded file should not fail")
	assert.Contains(t, string(content), "This is a test file.", "Downloaded file content should match expected content")
}

func setup() (*config.Config, *zap.Logger, error) {
	cfg := config.NewConfig()
	cfg.Chain = config.Chain_Mainnet
	cfg.Debug = os.Getenv(config.Debug) == "true"
	cfg.DatabaseConfig = *tests.GetDbConfigFromEnv()

	l, err := logger.NewLogger(&logger.LoggerConfig{Debug: cfg.Debug})
	if err != nil {
		return nil, nil, err
	}

	return cfg, l, nil
}

func TestCreateAndRestoreSnapshot(t *testing.T) {
	tempDir := t.TempDir()
	dumpFile := filepath.Join(tempDir, "TestCreateAndRestoreSnapshot.dump")
	dumpFileHash := filepath.Join(tempDir, "TestCreateAndRestoreSnapshot.dump.sha256sum")

	cfg, l, setupErr := setup()
	if setupErr != nil {
		t.Fatal(setupErr)
	}

	t.Run("Create snapshot from a database with migrations", func(t *testing.T) {
		dbName, _, dbGrm, dbErr := postgres.GetTestPostgresDatabase(cfg.DatabaseConfig, cfg, l)
		if dbErr != nil {
			t.Fatal(dbErr)
		}

		snapshotCfg := &SnapshotConfig{
			OutputFile: dumpFile,
			Host:       cfg.DatabaseConfig.Host,
			Port:       cfg.DatabaseConfig.Port,
			User:       cfg.DatabaseConfig.User,
			Password:   cfg.DatabaseConfig.Password,
			DbName:     dbName,
			SchemaName: cfg.DatabaseConfig.SchemaName,
		}

		svc, err := NewSnapshotService(snapshotCfg, l)
		assert.NoError(t, err, "NewSnapshotService should not return an error")
		err = svc.CreateSnapshot()
		assert.NoError(t, err, "Creating snapshot should not fail")

		fileInfo, err := os.Stat(dumpFile)
		assert.NoError(t, err, "Snapshot file should be created")
		assert.Greater(t, fileInfo.Size(), int64(4096), "Snapshot file size should be greater than 4KB")

		// Verify the SHA256 hash of the created snapshot file
		hash, err := getFileHash(dumpFile)
		assert.NoError(t, err, "Getting file hash should not fail")

		expectedHash, err := exec.Command("sha256sum", dumpFile).Output()
		assert.NoError(t, err, "Executing sha256sum command should not fail")

		expectedHashStr := strings.Fields(string(expectedHash))[0]
		assert.Equal(t, expectedHashStr, hex.EncodeToString(hash), "File hash should match expected hash from sha256sum")

		t.Cleanup(func() {
			postgres.TeardownTestDatabase(dbName, cfg, dbGrm, l)
		})
	})

	t.Run("Restore snapshot to a new database", func(t *testing.T) {
		dbName, _, dbGrm, dbErr := postgres.GetTestPostgresDatabaseWithoutMigrations(cfg.DatabaseConfig, l)
		if dbErr != nil {
			t.Fatal(dbErr)
		}

		snapshotCfg := &SnapshotConfig{
			Input:       dumpFile,
			VerifyInput: true,
			Host:        cfg.DatabaseConfig.Host,
			Port:        cfg.DatabaseConfig.Port,
			User:        cfg.DatabaseConfig.User,
			Password:    cfg.DatabaseConfig.Password,
			DbName:      dbName,
			SchemaName:  cfg.DatabaseConfig.SchemaName,
		}
		svc, err := NewSnapshotService(snapshotCfg, l)
		assert.NoError(t, err, "NewSnapshotService should not return an error")
		err = svc.RestoreSnapshot()
		assert.NoError(t, err, "Restoring snapshot should not fail")

		// Validate the restore process by counting migration records before and after running migrations
		// Step 1: Validate the restore process
		var countBeforeMigration int64
		err = dbGrm.Raw("SELECT COUNT(*) FROM migrations").Scan(&countBeforeMigration).Error
		assert.NoError(t, err, "Query error: %v", err)

		// Step 2: Setup your migrator for db (the restored snapshot) and attempt running all migrations
		migrator := migrations.NewMigrator(nil, dbGrm, l, cfg)
		err = migrator.MigrateAll()
		assert.NoError(t, err, "Expected MigrateAll to succeed on db")

		// Step 3: Count again after running migrations
		var countAfterMigration int64
		dbGrm.Raw("SELECT COUNT(*) FROM migrations").Scan(&countAfterMigration)

		// Step 4: If countBeforeMigration == countAfterMigration, no new migration records were created
		//         => meaning db was already fully up-to-date
		assert.Equal(t, countBeforeMigration, countAfterMigration, "No migrations should have been newly applied if db matches the original")

		t.Cleanup(func() {
			postgres.TeardownTestDatabase(dbName, cfg, dbGrm, l)
		})
	})

	t.Run("Restore snapshot to a new database from URL", func(t *testing.T) {
		// Create a test server to serve the snapshot and hash files
		snapshotContent, err := os.ReadFile(dumpFile)
		assert.NoError(t, err, "Reading snapshot file should not fail")

		hashContent, err := os.ReadFile(dumpFileHash)
		assert.NoError(t, err, "Reading hash file should not fail")
		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.URL.Path == "/test_snapshot.dump.sha256sum" {
				if _, err := w.Write(hashContent); err != nil {
					t.Errorf("Failed to write hash content: %v", err)
				}
			} else if r.URL.Path == "/test_snapshot.dump" {
				if _, err := w.Write(snapshotContent); err != nil {
					t.Errorf("Failed to write snapshot content: %v", err)
				}
			} else {
				http.NotFound(w, r)
			}
		}))
		defer testServer.Close()

		// Append a filename to the test server URL
		snapshotURL := testServer.URL + "/test_snapshot.dump"

		dbName, _, dbGrm, dbErr := postgres.GetTestPostgresDatabaseWithoutMigrations(cfg.DatabaseConfig, l)
		if dbErr != nil {
			t.Fatal(dbErr)
		}

		snapshotCfg := &SnapshotConfig{
			Input:       snapshotURL,
			VerifyInput: true,
			Host:        cfg.DatabaseConfig.Host,
			Port:        cfg.DatabaseConfig.Port,
			User:        cfg.DatabaseConfig.User,
			Password:    cfg.DatabaseConfig.Password,
			DbName:      dbName,
			SchemaName:  cfg.DatabaseConfig.SchemaName,
		}
		svc, err := NewSnapshotService(snapshotCfg, l)
		assert.NoError(t, err, "NewSnapshotService should not return an error")
		err = svc.RestoreSnapshot()
		assert.NoError(t, err, "Restoring snapshot should not return an error")

		// Validate the restore process by counting migration records before and after running migrations
		// Step 1: Validate the restore process
		var countBeforeMigration int64
		err = dbGrm.Raw("SELECT COUNT(*) FROM migrations").Scan(&countBeforeMigration).Error
		assert.NoError(t, err, "Query error: %v", err)

		// Step 2: Setup your migrator for db (the restored snapshot) and attempt running all migrations
		migrator := migrations.NewMigrator(nil, dbGrm, l, cfg)
		err = migrator.MigrateAll()
		assert.NoError(t, err, "Expected MigrateAll to succeed on db")

		// Step 3: Count again after running migrations
		var countAfterMigration int64
		dbGrm.Raw("SELECT COUNT(*) FROM migrations").Scan(&countAfterMigration)

		// Step 4: If countBeforeMigration == countAfterMigration, no new migration records were created
		//         => meaning db was already fully up-to-date
		assert.Equal(t, countBeforeMigration, countAfterMigration, "No migrations should have been newly applied if db matches the original")

		t.Cleanup(func() {
			postgres.TeardownTestDatabase(dbName, cfg, dbGrm, l)
		})
	})

	t.Run("Restore snapshot to a new database from Manifest", func(t *testing.T) {
		snapshotContent, err := os.ReadFile(dumpFile)
		assert.NoError(t, err, "Reading snapshot file should not fail")

		hashContent, err := os.ReadFile(dumpFileHash)
		assert.NoError(t, err, "Reading hash file should not fail")

		// Create an unstarted test server
		testServer := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			fmt.Printf("Received request for URL: %s\n", r.URL.String())

			if strings.HasSuffix(r.URL.Path, ".sha256sum") {
				_, err := w.Write(hashContent)
				if err != nil {
					fmt.Printf("Error writing hash content: %v\n", err)
				}
			} else if strings.HasSuffix(r.URL.Path, ".dump") {
				_, err := w.Write(snapshotContent)
				if err != nil {
					fmt.Printf("Error writing snapshot content: %v\n", err)
				}
			} else {
				mockManifest := `{
					"meta": {
						"metadataVersion": "v1.0.0",
						"lastRefreshed": "2025-01-30T14:29:04Z"
					},
					"snapshots": [
						{
							"snapshotURL": "http://localhost:5050/snapshots/mainnet/sidecar_mainnet_v2.0.0_public_20250130103903.dump",
							"chain": "mainnet",
							"version": "v2.0.0",
							"schema": "public",
							"timestamp": "2025-01-30T10:39:03Z"
						}
					]
				}`
				_, err := w.Write([]byte(mockManifest))
				if err != nil {
					fmt.Printf("Error writing mock manifest: %v\n", err)
				}
			}
		}))

		// Set a fixed URL for the test server, dynamic testServer URLs break the mockManifest snapshotURL
		testServer.Listener.Close() // Close the auto-assigned listener
		fixedAddr := "127.0.0.1:5050"
		listener, err := net.Listen("tcp", fixedAddr)
		assert.NoError(t, err, "Failed to start test server on fixed address")
		testServer.Listener = listener
		testServer.Start()

		defer testServer.Close()

		// Use the fixed URL
		manifestURL := "http://" + fixedAddr + "/mock_manifest.json"

		dbName, _, dbGrm, dbErr := postgres.GetTestPostgresDatabaseWithoutMigrations(cfg.DatabaseConfig, l)
		if dbErr != nil {
			t.Fatal(dbErr)
		}

		snapshotCfg := &SnapshotConfig{
			ManifestURL: manifestURL,
			Version:     "v2.0.0",
			Chain:       "mainnet",
			SchemaName:  "public",
			VerifyInput: true,
			Host:        cfg.DatabaseConfig.Host,
			Port:        cfg.DatabaseConfig.Port,
			User:        cfg.DatabaseConfig.User,
			Password:    cfg.DatabaseConfig.Password,
			DbName:      dbName,
		}
		svc, err := NewSnapshotService(snapshotCfg, l)
		assert.NoError(t, err, "NewSnapshotService should not return an error")

		// Call the RestoreSnapshot function
		err = svc.RestoreSnapshot()
		assert.NoError(t, err, "Restoring snapshot should not return an error")

		// Validate the restore process by counting migration records before and after running migrations
		// Step 1: Validate the restore process
		var countBeforeMigration int64
		err = dbGrm.Raw("SELECT COUNT(*) FROM migrations").Scan(&countBeforeMigration).Error
		assert.NoError(t, err, "Query error: %v", err)

		// Step 2: Setup your migrator for db (the restored snapshot) and attempt running all migrations
		migrator := migrations.NewMigrator(nil, dbGrm, l, cfg)
		err = migrator.MigrateAll()
		assert.NoError(t, err, "Expected MigrateAll to succeed on db")

		// Step 3: Count again after running migrations
		var countAfterMigration int64
		dbGrm.Raw("SELECT COUNT(*) FROM migrations").Scan(&countAfterMigration)

		// Step 4: If countBeforeMigration == countAfterMigration, no new migration records were created
		//         => meaning db was already fully up-to-date
		assert.Equal(t, countBeforeMigration, countAfterMigration, "No migrations should have been newly applied if db matches the original")

		t.Cleanup(func() {
			postgres.TeardownTestDatabase(dbName, cfg, dbGrm, l)
		})
	})

	t.Cleanup(func() {
		os.Remove(dumpFile)
		os.Remove(dumpFileHash)
	})
}

func TestIsHttpURL(t *testing.T) {
	tests := []struct {
		input    string
		expected bool
	}{
		{"http://example.com", true},
		{"https://example.com", true},
		{"", false},
		{"not-a-url", false},
		{"http://example.com/path?query=string", true},
		{"example.com", false},
		{"http://localhost:8080", true},
		{"C:\\Users\\User\\Documents\\file.txt", false}, // Windows file path
		{"/home/user/documents/file.txt", false},        // Unix file path
		{"./relative/path/to/file.txt", false},          // Relative file path
		{"../parent/directory/file.txt", false},         // Parent directory file path
		{"/var/folders/s1/8v9g67s150q9tqr5g6wnws7m0000gn/T/TestValidateRestoreConfig2732017660/001/TestValidateRestoreConfig.sql", false},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf("isHttpURL(%q)", test.input), func(t *testing.T) {
			result := isHttpURL(test.input)
			assert.Equal(t, test.expected, result, "isHttpURL(%q) should be %v", test.input, test.expected)
		})
	}
}

func TestGetDesiredURLFromManifest(t *testing.T) {
	// Create a mock manifest JSON
	mockManifest := `{
		"meta": {
			"metadataVersion": "v1.0.0",
			"lastRefreshed": "2025-01-30T14:29:04Z"
		},
		"snapshots": [
			{
				"snapshotURL": "https://sidecar.eigenlayer.xyz/snapshots/mainnet/sidecar_mainnet_v2.0.0_public_20250130103903.dump",
				"chain": "mainnet",
				"version": "v2.0.0",
				"schema": "public",
				"timestamp": "2025-01-30T10:39:03Z"
			},
			{
				"snapshotURL": "https://sidecar.eigenlayer.xyz/snapshots/holesky/sidecar_holesky_v3.0.0-rc.1_sidecar_testnet_holesky_20250130140613.dump",
				"chain": "testnet",
				"version": "v3.0.0-rc.1",
				"schema": "sidecar_testnet_holesky",
				"timestamp": "2025-01-30T14:06:13Z"
			}
		]
	}`

	// Create a test server to serve the mock manifest
	testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, mockManifest)
	}))
	defer testServer.Close()

	// Append a filename to the test server URL
	manifestURL := testServer.URL + "/mock_manifest.json"

	// Setup the SnapshotService with the desired configuration
	cfg := &SnapshotConfig{
		Version:    "v2.0.0",
		Chain:      "mainnet",
		SchemaName: "public",
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")

	// Call the function to test
	desiredURL, err := svc.getDesiredURLFromManifest(manifestURL)
	assert.NoError(t, err, "getDesiredURLFromManifest should not return an error")
	assert.Equal(t, "https://sidecar.eigenlayer.xyz/snapshots/mainnet/sidecar_mainnet_v2.0.0_public_20250130103903.dump", desiredURL, "The desired URL should match the expected snapshot URL")
}

func TestDownloadSnapshotAndVerificationFilesWithVerifyInput(t *testing.T) {
	// Create a test server to serve the snapshot and hash files
	snapshotContent := "This is a test snapshot file."
	hashContent := fmt.Sprintf("%x  test_snapshot.dump", sha256.Sum256([]byte(snapshotContent)))

	testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.HasSuffix(r.URL.Path, ".sha256sum") {
			fmt.Fprintln(w, hashContent)
		} else {
			fmt.Fprintln(w, snapshotContent)
		}
	}))
	defer testServer.Close()
	// Append a unique identifier to the test server URL
	snapshotURL := testServer.URL + "/test_snapshot_" + fmt.Sprintf("%d", time.Now().UnixNano()) + ".dump"

	cfg := &SnapshotConfig{
		VerifyInput: true,
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")

	// Call the function to test
	resolvedFilePath, err := svc.downloadSnapshotAndVerificationFiles(snapshotURL)
	assert.NoError(t, err, "downloadSnapshotAndVerificationFiles should not return an error")

	// Verify the snapshot file content
	content, err := os.ReadFile(resolvedFilePath)
	assert.NoError(t, err, "Reading downloaded snapshot file should not fail")
	assert.Contains(t, string(content), snapshotContent, "Snapshot file content should match expected content")

	// Verify the hash file content
	hashFilePath := getHashName(resolvedFilePath)
	hashContentRead, err := os.ReadFile(hashFilePath)
	assert.NoError(t, err, "Reading hash file should not fail")
	assert.Equal(t, hashContent, strings.TrimSpace(string(hashContentRead)), "Hash file content should match expected content")
}

func TestDownloadSnapshotAndVerificationFilesWithoutVerifyInput(t *testing.T) {
	// Create a test server to serve the snapshot and hash files
	snapshotContent := "This is a test snapshot file."
	hashContent := fmt.Sprintf("%x  test_snapshot.dump", sha256.Sum256([]byte(snapshotContent)))

	testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.HasSuffix(r.URL.Path, ".sha256sum") {
			fmt.Fprintln(w, hashContent)
		} else {
			fmt.Fprintln(w, snapshotContent)
		}
	}))
	defer testServer.Close()

	// Append a filename to the test server URL
	snapshotURL := testServer.URL + "/test_snapshot_" + fmt.Sprintf("%d", time.Now().UnixNano()) + ".dump"

	cfg := &SnapshotConfig{
		VerifyInput: false,
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")

	// Call the function to test
	resolvedFilePath, err := svc.downloadSnapshotAndVerificationFiles(snapshotURL)
	assert.NoError(t, err, "downloadSnapshotAndVerificationFiles should not return an error")

	// Verify the snapshot file content
	content, err := os.ReadFile(resolvedFilePath)
	assert.NoError(t, err, "Reading downloaded snapshot file should not fail")
	assert.Contains(t, string(content), snapshotContent, "Snapshot file content should match expected content")

	// Ensure no hash file is created
	hashFilePath := getHashName(resolvedFilePath)
	_, err = os.Stat(hashFilePath)
	assert.True(t, os.IsNotExist(err), "Hash file should not exist when VerifyInput is false")
}
