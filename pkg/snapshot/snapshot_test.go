package snapshot

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/Layr-Labs/sidecar/internal/config"
	"github.com/Layr-Labs/sidecar/internal/logger"
	"github.com/Layr-Labs/sidecar/internal/tests"
	"github.com/Layr-Labs/sidecar/pkg/postgres"
	"github.com/Layr-Labs/sidecar/pkg/postgres/migrations"
	"github.com/stretchr/testify/assert"
	"go.uber.org/zap"
)

func TestNewSnapshotService(t *testing.T) {
	cfg := &SnapshotConfig{}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	assert.NotNil(t, svc, "SnapshotService should not be nil")
	assert.Equal(t, cfg, svc.cfg, "SnapshotConfig should match")
	assert.Equal(t, l, svc.l, "Logger should match")
}

func TestValidateCreateSnapshotConfig(t *testing.T) {
	cfg := &SnapshotConfig{
		Host:       "localhost",
		Port:       5432,
		DbName:     "testdb",
		User:       "testuser",
		Password:   "testpassword",
		SchemaName: "public",
		OutputFile: "/tmp/test_snapshot.sql",
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	err = svc.validateCreateSnapshotConfig()
	assert.NoError(t, err, "Snapshot config should be valid")
}

func TestValidateCreateSnapshotConfigMissingOutputFile(t *testing.T) {
	cfg := &SnapshotConfig{
		Host:       "localhost",
		Port:       5432,
		DbName:     "testdb",
		User:       "testuser",
		Password:   "testpassword",
		SchemaName: "public",
		OutputFile: "",
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	err = svc.validateCreateSnapshotConfig()
	assert.Error(t, err, "Snapshot config should be invalid if output file is missing")
}

func TestSetupSnapshotDump(t *testing.T) {
	cfg := &SnapshotConfig{
		Host:       "localhost",
		Port:       5432,
		DbName:     "testdb",
		User:       "testuser",
		Password:   "testpassword",
		SchemaName: "public",
		OutputFile: "/tmp/test_snapshot.sql",
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	dump, err := svc.setupSnapshotDump()
	assert.NoError(t, err, "Dump setup should not fail")
	assert.NotNil(t, dump, "Dump should not be nil")
}

func TestSetupRestore(t *testing.T) {
	cfg := &SnapshotConfig{
		Host:        "localhost",
		Port:        5432,
		DbName:      "testdb",
		User:        "testuser",
		Password:    "testpassword",
		SchemaName:  "public",
		Input:       "/tmp/test_snapshot.sql",
		VerifyInput: true,
	}
	l, _ := zap.NewDevelopment()
	svc, err := NewSnapshotService(cfg, l)
	assert.NoError(t, err, "NewSnapshotService should not return an error")
	restore, err := svc.setupRestore()
	assert.NoError(t, err, "Restore setup should not fail")
	assert.NotNil(t, restore, "Restore should not be nil")
}

func TestSaveOutputFileHash(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "TestSaveOutputFileHash.sql")
	outputHashFile := outputFile + ".sha256sum"
	_, err := os.Create(outputFile)
	assert.NoError(t, err, "Creating output file should not fail")

	// Use the pure function directly
	err = saveOutputFileHash(outputFile, outputHashFile)
	assert.NoError(t, err, "Saving output file hash should not fail")

	hash, err := os.ReadFile(outputHashFile)
	assert.NoError(t, err, "Reading output hash file should not fail")
	assert.NotEmpty(t, hash, "Output hash file should not be empty")

	// Validate the hash file content
	hashParts := strings.Fields(string(hash))
	assert.Equal(t, 2, len(hashParts), "Output hash file should contain two parts: hash and filename")
	assert.Equal(t, filepath.Base(outputFile), hashParts[1], "Output hash file should contain the correct filename")
	assert.Equal(t, sha256.Size*2, len(hashParts[0]), "Output hash file should have the correct hash length")

	// Compare the hash with the one generated by sha256sum
	cmd := exec.Command("sha256sum", outputFile)
	sha256sumOutput, err := cmd.Output()
	assert.NoError(t, err, "Executing sha256sum should not fail")

	sha256sumParts := strings.Fields(string(sha256sumOutput))
	assert.Equal(t, 2, len(sha256sumParts), "sha256sum output should contain two parts: hash and filename")
	assert.Equal(t, sha256sumParts[0], hashParts[0], "Hashes should match between sha256sum and saveOutputFileHash")
}

func TestSaveOutputFileHashCompatibilityWithSha256sum(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "TestSaveOutputFileHashCompatibility.sql")
	outputHashFile := getHashName(outputFile)

	// Create a dummy output file
	content := []byte("test content for sha256sum compatibility")
	err := os.WriteFile(outputFile, content, 0644)
	assert.NoError(t, err, "Creating output file should not fail")

	// Generate the hash file
	err = saveOutputFileHash(outputFile, outputHashFile)
	assert.NoError(t, err, "Saving output file hash should not fail")

	// Use sha256sum -c to verify the hash
	cmd := exec.Command("sha256sum", "-c", outputHashFile)
	cmd.Dir = tempDir // Ensure the command runs in the directory containing the files
	err = cmd.Run()
	assert.NoError(t, err, "sha256sum -c should verify the hash successfully")
}

func TestCleanupTempFiles(t *testing.T) {
	tempDir := t.TempDir()
	tempFile := filepath.Join(tempDir, "TestCleanupTempFiles.tmp")
	_, err := os.Create(tempFile)
	assert.NoError(t, err, "Creating temp file should not fail")

	// Use the standalone cleanupTempFiles function
	logger, _ := zap.NewDevelopment()
	cleanupTempFiles([]string{tempFile}, logger)

	_, err = os.Stat(tempFile)
	if !os.IsNotExist(err) {
		// Attempt to remove the file if it wasn't removed by the cleanupTempFiles
		removeErr := os.Remove(tempFile)
		assert.NoError(t, removeErr, "Removing temp file manually should not fail")
	}
	assert.True(t, os.IsNotExist(err), "Temp file should be removed")
}

func TestValidateInputFileHash(t *testing.T) {
	tempDir := t.TempDir()
	inputFile := filepath.Join(tempDir, "TestValidateInputFileHash.sql")
	hashFile := filepath.Join(tempDir, "TestValidateInputFileHash.sql.sha256sum")
	content := []byte("test content")
	err := os.WriteFile(inputFile, content, 0644)
	assert.NoError(t, err, "Writing to input file should not fail")

	// Shell out to sha256sum to create the hash file
	cmd := exec.Command("sha256sum", inputFile)
	sha256sumOutput, err := cmd.Output()
	assert.NoError(t, err, "Executing sha256sum should not fail")

	// Write the sha256sum output to the hash file
	err = os.WriteFile(hashFile, sha256sumOutput, 0644)
	assert.NoError(t, err, "Writing sha256sum output to hash file should not fail")

	err = validateInputFileHash(inputFile)
	assert.NoError(t, err, "Input file hash should be valid")
}

func TestGetFileHash(t *testing.T) {
	tempDir := t.TempDir()
	inputFile := filepath.Join(tempDir, "TestGetFileHash.sql")
	content := []byte("test content")
	err := os.WriteFile(inputFile, content, 0644)
	assert.NoError(t, err, "Writing to input file should not fail")

	hash, err := getFileHash(inputFile)
	assert.NoError(t, err, "Getting file hash should not fail")

	expectedHash := sha256.Sum256(content)
	assert.Equal(t, expectedHash[:], hash, "File hash should match expected hash")
}

func TestDownloadFile(t *testing.T) {
	// Create a test server that serves a simple text file
	testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, "This is a test file.")
	}))
	defer testServer.Close()

	// Generate unique file names using the current timestamp
	uniqueID := fmt.Sprintf("%d", time.Now().UnixNano())
	inputFileName := uniqueID + "_downloaded_snapshot.dump"

	tempDir := t.TempDir()
	inputFilePath := filepath.Join(tempDir, inputFileName)

	// Use the test server's URL to test the downloadFile function
	err := downloadFile(testServer.URL, inputFilePath)
	assert.NoError(t, err, "downloadFile should not return an error")

	// Schedule the file for removal after the test completes
	defer func() {
		if err := os.Remove(inputFilePath); err != nil {
			t.Logf("Failed to remove downloaded file: %v", err)
		}
	}()

	// Verify the file was downloaded correctly
	content, err := os.ReadFile(inputFilePath)
	assert.NoError(t, err, "Reading downloaded file should not fail")
	assert.Contains(t, string(content), "This is a test file.", "Downloaded file content should match expected content")
}

func setup() (*config.Config, *zap.Logger, error) {
	cfg := config.NewConfig()
	cfg.Chain = config.Chain_Mainnet
	cfg.Debug = os.Getenv(config.Debug) == "true"
	cfg.DatabaseConfig = *tests.GetDbConfigFromEnv()

	l, err := logger.NewLogger(&logger.LoggerConfig{Debug: cfg.Debug})
	if err != nil {
		return nil, nil, err
	}

	return cfg, l, nil
}

func TestCreateAndRestoreSnapshot(t *testing.T) {
	tempDir := t.TempDir()
	dumpFile := filepath.Join(tempDir, "TestCreateAndRestoreSnapshot.dump")
	dumpFileHash := filepath.Join(tempDir, "TestCreateAndRestoreSnapshot.dump.sha256sum")

	cfg, l, setupErr := setup()
	if setupErr != nil {
		t.Fatal(setupErr)
	}

	t.Run("Create snapshot from a database with migrations", func(t *testing.T) {
		dbName, _, dbGrm, dbErr := postgres.GetTestPostgresDatabase(cfg.DatabaseConfig, cfg, l)
		if dbErr != nil {
			t.Fatal(dbErr)
		}

		snapshotCfg := &SnapshotConfig{
			OutputFile: dumpFile,
			Host:       cfg.DatabaseConfig.Host,
			Port:       cfg.DatabaseConfig.Port,
			User:       cfg.DatabaseConfig.User,
			Password:   cfg.DatabaseConfig.Password,
			DbName:     dbName,
			SchemaName: cfg.DatabaseConfig.SchemaName,
		}

		svc, err := NewSnapshotService(snapshotCfg, l)
		assert.NoError(t, err, "NewSnapshotService should not return an error")
		err = svc.CreateSnapshot()
		assert.NoError(t, err, "Creating snapshot should not fail")

		fileInfo, err := os.Stat(dumpFile)
		assert.NoError(t, err, "Snapshot file should be created")
		assert.Greater(t, fileInfo.Size(), int64(4096), "Snapshot file size should be greater than 4KB")

		// Verify the SHA256 hash of the created snapshot file
		hash, err := getFileHash(dumpFile)
		assert.NoError(t, err, "Getting file hash should not fail")

		expectedHash, err := exec.Command("sha256sum", dumpFile).Output()
		assert.NoError(t, err, "Executing sha256sum command should not fail")

		expectedHashStr := strings.Fields(string(expectedHash))[0]
		assert.Equal(t, expectedHashStr, hex.EncodeToString(hash), "File hash should match expected hash from sha256sum")

		t.Cleanup(func() {
			postgres.TeardownTestDatabase(dbName, cfg, dbGrm, l)
		})
	})

	t.Run("Restore snapshot to a new database", func(t *testing.T) {
		dbName, _, dbGrm, dbErr := postgres.GetTestPostgresDatabaseWithoutMigrations(cfg.DatabaseConfig, l)
		if dbErr != nil {
			t.Fatal(dbErr)
		}

		snapshotCfg := &SnapshotConfig{
			Input:       dumpFile,
			VerifyInput: true,
			Host:        cfg.DatabaseConfig.Host,
			Port:        cfg.DatabaseConfig.Port,
			User:        cfg.DatabaseConfig.User,
			Password:    cfg.DatabaseConfig.Password,
			DbName:      dbName,
			SchemaName:  cfg.DatabaseConfig.SchemaName,
		}
		svc, err := NewSnapshotService(snapshotCfg, l)
		assert.NoError(t, err, "NewSnapshotService should not return an error")
		err = svc.RestoreSnapshot()
		assert.NoError(t, err, "Restoring snapshot should not fail")

		// Validate the restore process

		// 1) Count how many migration records already exist in db
		var countBefore int64
		dbGrm.Raw("SELECT COUNT(*) FROM migrations").Scan(&countBefore)

		// 2) Setup your migrator for db (the restored snapshot) and attempt running all migrations
		migrator := migrations.NewMigrator(nil, dbGrm, l, cfg)
		err = migrator.MigrateAll()
		assert.NoError(t, err, "Expected MigrateAll to succeed on db")

		// 3) Count again after running migrations
		var countAfter int64
		dbGrm.Raw("SELECT COUNT(*) FROM migrations").Scan(&countAfter)

		// 4) If countBefore == countAfter, no new migration records were created
		//    => meaning db was already fully up-to-date
		assert.Equal(t, countBefore, countAfter, "No migrations should have been newly applied if db matches the original")

		t.Cleanup(func() {
			postgres.TeardownTestDatabase(dbName, cfg, dbGrm, l)
		})
	})

	t.Cleanup(func() {
		os.Remove(dumpFile)
		os.Remove(dumpFileHash)
	})
}

func TestIsHttpURL(t *testing.T) {
	tests := []struct {
		input    string
		expected bool
	}{
		{"http://example.com", true},
		{"https://example.com", true},
		{"", false},
		{"not-a-url", false},
		{"http://example.com/path?query=string", true},
		{"example.com", false},
		{"http://localhost:8080", true},
		{"C:\\Users\\User\\Documents\\file.txt", false}, // Windows file path
		{"/home/user/documents/file.txt", false},        // Unix file path
		{"./relative/path/to/file.txt", false},          // Relative file path
		{"../parent/directory/file.txt", false},         // Parent directory file path
		{"/var/folders/s1/8v9g67s150q9tqr5g6wnws7m0000gn/T/TestValidateRestoreConfig2732017660/001/TestValidateRestoreConfig.sql", false},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf("isHttpURL(%q)", test.input), func(t *testing.T) {
			result := isHttpURL(test.input)
			assert.Equal(t, test.expected, result, "isHttpURL(%q) should be %v", test.input, test.expected)
		})
	}
}
